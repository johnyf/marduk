##  ===========================================================================
##  Author: Georg Hofferek <georg.hofferek@iaik.tugraz.at>
##
##  Copyright (c) 2009, 2010 by Graz University of Technology 
##
##  This is free software; you can redistribute it and/or
##  modify it under the terms of the GNU Lesser General Public
##  License as published by the Free Software Foundation; either
##  version 2 of the License, or (at your option) any later version.
##
##  This software is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
##  Lesser General Public License for more details.
##
##  You should have received a copy of the GNU Lesser General Public
##  License along with this library; if not, write to the Free Software
##  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
##
##  For more information about this software see <http://rat.fbk.eu/ratsy>
##  or email to the RATSY Team <ratsy@list.fbk.eu>.
##  Please report bugs to <ratsy@list.fbk.eu>.
##
##  ===========================================================================


"""
This module contains classes to generate code from BDDs.
"""

import marduk_utils
from marduk_utils import MardukException

class CodeGenerator(object):
    """
    Base class for all code generators.
    Provides general methods for creating input/output signals/variables, temporary
    wires/variables and simple logic operations between those.
    Information about the circuit will be stored in internal lists. Actual code will
    be generated by subclasses for specific languages, e.g. Verilog.
    """
        
    def __init__(self, code_file, module_name="main", comment_sign=''):
        self._code_file_name = code_file
        self._codefile = open(code_file, 'w')
        self._inputs = []
        self._outputs = []
        self._tmp_vars = ["zero", "one"]
        self._logic_operations = []
        self._flipflops = []
        self._wire_size = {}
        self._module_name = module_name
        self._comment_sign = comment_sign

        # Counter for creating (unique) temporary names for
        # variables/signals
        self.__tmp_counter = 0

        
    def __del__(self):
        self._codefile.close()

    def append_comment(self, lines):
        """
        This method appends the given lines as a comment to the already existing code_file.
        If the file is still open, write directly to it, otherwise reopen and append.
        """
        was_open = False
        if ~self._codefile.closed:
            file = self._codefile
            was_open = True
        else:
            file = open(self._code_file_name, 'a')

        file.write('\n\n')
        file.write(self._comment_sign +
                   ' ---------------------------------------------------------------------------\n')
        for line in lines:
            import re
            subs_line = re.sub('\n','\n' + self._comment_sign + ' ', line)
            file.write(self._comment_sign + ' ' + subs_line + '\n')
        file.write('\n')
        if ~was_open:
            file.close()

    def circuit_size(self, wire):
        """
        Reports the size of the circuit in the (transitiv) fan-in of the given wire.
        The size is reported in "gate equivalents" (GE), with the following basic sizes:
        Inverter (NOT) = 0.5 GE
        2-input-AND = 2-input-OR = 1 GE
        n-input-AND = n-input-OR = n/2 GE
        MUX = 2.5 GE

        Flipflops are not counted. Wire originating from flipflops are treated like primary inputs.
        """
        if not (self._check_signal_exists(wire) or self._wire_size.has_key(wire)):
            raise MardukException("Given wire '%s' does not exist!" % wire)

        if not self._wire_size.has_key(wire):
            return 0   # The wire exists, but is not listed in the table. It must be a primary input, a constant, or the output of a flipflop.

        return self._wire_size[wire]
        
        
    def create_tmp_var(self):
        """
        Creates a temporary variable name and appends it to the list of temporary variables.
        """
        name = "tmp" + str(self.__tmp_counter)
        self.__tmp_counter = self.__tmp_counter + 1
        self._tmp_vars.append(name);
        return name

    def _add_gate(self, gate, prepend=False):
        """
        Adds a gate to the list of logic operations.
        If prepend is TRUE, then it will be added at the front of the list,
        otherwise at the end.
        """
        if(prepend):
            self._logic_operations = [gate] +  self._logic_operations
        else:
            self._logic_operations.append(gate)

            
    def _check_signal_exists(self, name):
        """
        Checks if the given name is already declared as an input,
        temporary variable or flipflop output. If not, a MardukException is raised.
        """
        if(not(name in self._inputs or name in self._tmp_vars
               or name in [flipflop['name'] for flipflop in self._flipflops])):
            raise MardukException(("ERROR! No input, tmp_var, or flipflop output named '%s'!" % name))
        else:
            return True
      
                    
    def add_input(self, name):
        """
        Adds the given name to the list of inputs.
        Raises a MardukException if the name has already been declared before.
        """
        if(name in self._inputs):
            raise MardukException(("ERROR! Already defined input '%s'!" % name))
        else:
            self._inputs.append(name)

            
    def add_output(self, name, signal):
        """
        Adds the given name to the list of outputs and
        connects it to the specified (internal) signal.
        Raises a MardukException if either the name has been declared
        as an output before, or the internal signal does not exist.
        """
        if(name in self._outputs):
            raise MardukException(("ERROR! Already defined output '%s'!" % name))

        self._check_signal_exists(signal)
        self._outputs.append({'name': name, 'signal':signal})

            
    def add_not(self, name, prepend=False):
        """
        Adds a NOT gate with the specified signal name as input.
        Returns the output signal name.
        If the given signal does not exist a MardukException is raised.
        If prepend is set to true, the gate will be added in the front
        of the logic operations list.
        """
        self._check_signal_exists(name)
        result = self.create_tmp_var()
        gate = {'function': "NOT", 'input': name, 'output': result}
        self._add_gate(gate, prepend)
        self._wire_size[result] = self.circuit_size(name) + 0.5
        return result
    

    def add_and(self, inputs, prepend=False):
        """
        Adds an AND gate with the specified signal names as input.
        Returns the output signal name.
        If one of the the given signals does not exist a MardukException is raised.
        If prepend is set to true, the gate will be added in the front
        of the logic operations list.
        """
        for name in inputs:
            self._check_signal_exists(name)

        result = self.create_tmp_var()
        gate = {'function': "AND", 'inputs': inputs, 'output': result}
        self._add_gate(gate, prepend)
        self._wire_size[result] = sum([self.circuit_size(wire) for wire in inputs]) + len(inputs)/2
        return result

    
    def add_or(self, inputs, prepend=False):
        """
        Adds an OR gate with the specified signal names as input.
        Returns the output signal name.
        If one of the the given signals does not exist a MardukException is raised.
        If prepend is set to true, the gate will be added in the front
        of the logic operations list.
        """
        for name in inputs:
            self._check_signal_exists(name)

        result = self.create_tmp_var()
        gate = {'function': "OR", 'inputs': inputs, 'output': result}
        self._add_gate(gate, prepend)
        self._wire_size[result] = sum([self.circuit_size(wire) for wire in inputs]) + len(inputs)/2        
        return result        


    def add_mux(self, sel, in_then, in_else, prepend=False):
        """
        Adds a 2:1-MUX gate with the specified signal names as input.
        Returns the output signal name.
        If one of the the given signals does not exist a MardukException is raised.
        If prepend is set to true, the gate will be added in the front
        of the logic operations list.
        """
        for name in [sel, in_then, in_else]:
            self._check_signal_exists(name)
            
        result = self.create_tmp_var()
        gate = {'function' : "MUX", 'sel':sel, 'in_then':in_then, 'in_else':in_else, 'output':result}
        self._add_gate(gate, prepend)
        self._wire_size[result] = sum([self.circuit_size(wire) for wire in [sel, in_then, in_else]]) + 2.5 
        return result
            

    def add_flipflop(self, name, input, initial):
        """
        Adds a flipflop with the given name, whose input will be connected
        to the given signal. The initial value will be set to the given initial value.
        If the given signal does not exist, or if a flipflop with that name has been
        registered before, a MardukException is raised.

        If input==None, then the check for existence will be omitted. The input to the fliflop
        will be set to the zero wire. It can, however, be changed later on by using the method
        change_flipflop_input.
        """
        if(name in [flipflop['name'] for flipflop in self._flipflops]):
            raise MardukException(("ERROR! Already defined flipflop '%s'!" % name))
        if input != None:
            self._check_signal_exists(input)
            self._flipflops.append({'name':name, 'input':input, 'initial':initial})
        else:
            self._flipflops.append({'name':name, 'input':'zero', 'initial':initial})


    def change_flipflop_input(self, name, input):
        """
        Changes the input of the flipflop with the given name to the given signal.
        Raises an exception if the given flipflop does not exist.
        """
        self._check_signal_exists(input)
        for flipflop in self._flipflops:
            if flipflop['name'] == name:
                flipflop.update({'input':input})
                return

        # flipflop not found    
        raise MardukException(("ERROR! No flipflop with name '%s'!" % name))
        
    def wire2BDD(self, name, vars):
        """
        Recursively computes the BDD corresponding to the given wire.
        vars is a list of Marduk variables, to be able to transform primary
        inputs and flipflop outputs into BDDs, according to their name.
        """
        from bddwrap import BDD
        mgr = vars[0].ps.mgr
        # First check whether the wire exists at all

        self._check_signal_exists(name)
           
        # Now check whether we have a terminal case, i.e., if the given
        # wire is a primary input, or a flip-flop output, or a constant

        if name == 'zero':
            return BDD.ZERO(mgr)
        if name == 'one':
            return BDD.ONE(mgr)
        
        if name in self._inputs:
            var = [var for var in vars if var.name == name]
            if len(var) == 1:
                return var[0].ns

        flipflop = [flipflop['name'] for flipflop in self._flipflops if flipflop['name'] == name]
        if len(flipflop) == 1:
            flipflop_varname = flipflop[0][0:-3]  # get rid of '_ps'
            var = [var for var in vars if var.name == flipflop_varname]
            if len(var) == 1:
                return var[0].ps

            
        # Not a termincal case. --> Check gates and call recursively

        gate = [gate for gate  in self._logic_operations if gate['output'] == name]
        if len(gate) != 1:
            raise MardukException("Signal %s not found, although it should exist." % name)
        gate = gate[0]

        if gate['function'] == 'NOT':
            return ~self.wire2BDD(gate['input'], vars)

        if gate['function'] == 'AND':
            result = BDD.ONE(mgr)
            for input in gate['inputs']:
                result *= self.wire2BDD(input, vars)
            return result

        if gate['function'] == 'OR':
            result = BDD.ZERO(mgr)
            for input in gate['inputs']:
                result += self.wire2BDD(input, vars)
            return result

        if gate['function'] == 'MUX':
            sel = self.wire2BDD(gate['sel'], vars)
            in_then = self.wire2BDD(gate['in_then'], vars)
            in_else = self.wire2BDD(gate['in_else'], vars)
            return sel * in_then + ~sel * in_else 

        raise MardukException("Encountered unknown gate '%s'." % gate['function'])
        
	      
      
      
    #####################################################################  

    def convert_functions_to_gates(self, marduk, output_functions, manager):
        
        import resource
        
        self.__marduk = marduk
        
        import marduk_utils
        
        input_names = []
        output_names = []
        wires = {}
        indices = {}
        handled_functions={}
        
        debug_handled = {}
        debug_hand2 = {}
        
        #create inputs and FFs
        for var in marduk.input_vars:
            #print ("Input: %s Index: %s" % (var.name, var.get_ps_bdd_ptr().get_index()))
            input_names.append(var.name)
            self.add_input(var.name)
            wires[str(var.ns)] = var.name
            initial = marduk_utils.get_init_value_from_bdd(var, self.__marduk.winning_region.init12 * self.__marduk.winning_region.initjx)
            self.add_flipflop(var.name + "_ps", var.name, initial)
            indices[var.ps.get_index()] = var.name +"_ps"
            indices[var.ns.get_index()] = var.name
        
        
        #create FFs for non input vars
        for var in marduk.vars:
            if(var.name in input_names):
                continue
            #print ("Type: %s \t Name: %s Index: %s" % (var.type, var.name, var.get_ps_bdd_ptr().get_index()))
            output_names.append(var.name)
            wires[str(var.ps)] = var.name + "_ps"
            initial  = marduk_utils.get_init_value_from_bdd(var, marduk.winning_region.init12 * marduk.winning_region.initjx)
            self.add_flipflop(var.name + "_ps", None, initial)
            indices[var.ps.get_index()] = var.name +"_ps"
            indices[var.ns.get_index()] = var.name

        
        #create Logic       
        if marduk.transfer_functions:
            before = resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime
            functions = {}
            from nusmv import dd
            self.__dd_mgr = dd.create_dd_manager(0,0,251,131071,0)  # Values from PerlDD
            if marduk.dyn_reorder:
                dd.dd_autodyn_enable(self.__dd_mgr, marduk.dyn_reorder_method)

            for key in output_functions.functions.keys():
                from bddwrap import BDD
                transferred_bdd = BDD(output_functions.functions[key].ptr, marduk.dd_mgr, dest_mgr=self.__dd_mgr)
                functions[key]= transferred_bdd
            self._transfer_time = resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime - before
            before = resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime
            dd.dd_reorder(self.__dd_mgr, marduk.reorder_method, 0)
            self._reorder_time =  resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime - before
            dd.dd_autodyn_disable(self.__dd_mgr)
        else:
            functions = output_functions.get_functions()
        
        results = {}        
        for function in functions:
           results[function] = self.conv_bdd(functions[function], handled_functions, indices)
# #           DEBUG Sanity check
#            if not functions[function] == self.wire2BDD(results[function], marduk.vars):
#                print "function"
#                functions[function].print_minterm()
#                print
#                print "Result"
#                self.wire2BDD(results[function], marduk.vars).print_minterm()
#                raise Exception
#            else:
#                print "OK"
# #           END DEBUG
        
        
        #add outputs and connect FF inputs for not input vars
        for var in marduk.vars:
            if(var.name in input_names):
                continue
            self.change_flipflop_input(var.name+"_ps", results[var.name])
            self.add_output(var.name, results[var.name])
            

  
    def isOneOrZero(self, bdd_object, manager):
        if(str(bdd_object) == str(bdd_object.ONE(bdd_object.mgr))):
            return "one"; 
        elif(str(bdd_object) == str(bdd_object.ZERO(bdd_object.mgr))):
            return "zero"; 
        else:
            return 0;
    
    ##FIX ME:
    """
    deteting if edge is an inverse by checking the 3rd sign in the Pointer, 
    edge is inverse isf the signe is 1
    """        
    def detect_inverse_edge(self, function):
        if(str(function)[2] == '1'):
            return 1
        else:
            return 0
        
    def conv_bdd(self, function, handled_functions, indices):
        manager = function.mgr
        const = self.isOneOrZero(function, manager)
        is_inverse = self.detect_inverse_edge(function)
        
        if(const == "one"):
            return const
        elif(const == "zero"):
            return const
        
        """
        Check if function or the inverse of the function is already calulated
        if inverse is handled, just inverse it
        """
        if(str(function) in handled_functions):
            return handled_functions[str(function)]
        elif(str(~function) in handled_functions):
            res = self.add_not(handled_functions[str(~function)])
            handled_functions[str(function)] = res
            
            return res
            
        sel = indices[function.get_index()]
        in_then = self.conv_bdd(function.THEN, handled_functions, indices)
        in0 = self.conv_bdd(function.ELSE, handled_functions, indices)
        res = self.add_mux(sel, in_then, in0)
        
        if(is_inverse == 1):
            inv_res = self.add_not(res)
            handled_functions[str(function)] = inv_res
            handled_functions[str(~function)] = res
            return inv_res
        else:
            handled_functions[str(function)] = res        
                        
        return res
        

#############################################################################################    
class VerilogGenerator(CodeGenerator): 
    """
    Generates Verilog code.
    """
    
    def __init__(self, output_file, module_name="main"):
        CodeGenerator.__init__(self, output_file, module_name=module_name, comment_sign='//')


    def write_code_to_file(self):
        """
        Generates Verilog code according to the current values
        of the internal data structures (such as list of inputs/outputs/flipflops,
        logic operations,...) and writes it to the output file.
        This methode should only be called ONCE, and only after ALL circuit elements have been
        created and connected.
        """
        self._write_main_modul_declaration()
        self._write_signal_declarations()
        self._write_signal_definitions()
        self._write_initial_block()
        self._write_always_block()
        self._write_end_module()


    def _write_main_modul_declaration(self):
        """
        Writes the module declaration in the following form:
        module main(clock,
          <all inputs>,
          <all outputs>);
        """
        self._codefile.write("module %s(clock,\n " % self._module_name)
      
        for input_name in self._inputs:
            self._codefile.write((" %s," % input_name))
        self._codefile.write("\n ")

        for output in self._outputs[0:(len(self._outputs)-1)]:
            self._codefile.write((" %s," % output['name']))
        self._codefile.write((" %s);\n\n" % self._outputs[len(self._outputs)-1]['name']))


        
    def _write_signal_declarations(self):
        """
        Writes declarations for all signals, in the following order:
        Inputs, Outputs, internal wires, regs (flipflops).
        """
        self._codefile.write("  input clock;\n")
        
        for input_name in self._inputs:
            self._codefile.write(("  input %s;\n" % input_name))

        for output in self._outputs:
            self._codefile.write(("  output %s;\n" % output['name']))

        for wire in self._tmp_vars:
            self._codefile.write(("  wire %s;\n" % wire))

        for reg in self._flipflops:
            self._codefile.write(("  reg %s;\n" % reg['name']))

        self._codefile.write("\n\n")
            

        
    def _write_signal_definitions(self):
        """
        Writes assign statements for all logic operations in the
        order in which they appear in the internal list.
        """
        for gate in self._logic_operations:
            if gate['function'] == 'NOT':
                self._codefile.write(("  assign %s = !%s;\n" % (gate['output'], gate['input'])))
            elif gate['function'] == 'AND':
                self._codefile.write(("  assign %s =" % gate['output']))
                for input_name in gate['inputs'][0:len(gate['inputs'])-1]:
                    self._codefile.write((" %s &" % input_name))
                self._codefile.write((" %s;\n" % gate['inputs'][len(gate['inputs'])-1]))
            elif gate['function'] == 'OR':
                self._codefile.write(("  assign %s =" % gate['output']))
                for input_name in gate['inputs'][0:len(gate['inputs'])-1]:
                    self._codefile.write((" %s |" % input_name))
                self._codefile.write((" %s;\n" % gate['inputs'][len(gate['inputs'])-1]))
            elif gate['function'] == 'MUX':
                self._codefile.write(("  assign %s = %s ? %s : %s;\n" %(gate['output'], gate['sel'],
                                      gate['in_then'], gate['in_else'])))
            else:
                raise MardukException(("ERROR! Unknown gate type '%s'!" % gate['function']))

        for output in self._outputs:
            self._codefile.write(("  assign %s = %s;\n" % (output['name'], output['signal'])))

        self._codefile.write("  assign zero = 0;\n  assign one = 1;\n")
        
    
    def _write_initial_block(self):
        """
        Writes the initial block which initializes all regs (flipflops).
        """
        self._codefile.write("  initial\n  begin\n")

        for ff in self._flipflops:
            self._codefile.write(("    %s = %s;\n" % (ff['name'], ff['initial'])))

        self._codefile.write("  end\n")

        

        
    def _write_always_block(self):
        """
        Writes the always block which updates all regs (flipflops) at
        each positive edge of 'clock'.
        """
        self._codefile.write("  always @(posedge clock)\n  begin\n")

        for ff in self._flipflops:
            self._codefile.write(("    %s = %s;\n" % (ff['name'], ff['input'])))

        self._codefile.write("  end\n")

    
        
    def _write_end_module(self):
        """
        Writes the 'endmodule' line.
        """
        self._codefile.write("endmodule\n")
                        

        
#############################################################################################    
class BlifFromGatesGenerator(CodeGenerator): 
    """
    Generates BLIF code, gate by gate, according to internal lists.
    """
    
    def __init__(self, output_file, module_name="main"):
        CodeGenerator.__init__(self, output_file, module_name=module_name, comment_sign='#')


    def write_code_to_file(self):
        """
        Generates BLIF code according to the current values
        of the internal data structures (such as list of inputs/outputs/flipflops,
        logic operations,...) and writes it to the output file.
        This methode should only be called ONCE, and only after ALL circuit elements have been
        created and connected.
        """
        self._write_main_modul_declaration()
        self._write_signal_definitions()
        self._write_latches()
        self._write_end_module()


    def _write_main_modul_declaration(self):
        """
        Writes the module declaration.
        """
        self._codefile.write(".model %s\n" % self._module_name)

        self._codefile.write(".inputs")
        for input_name in self._inputs:
            self._codefile.write((" %s" % input_name))
        self._codefile.write("\n")
                             
        self._codefile.write(".outputs")
        for output in self._outputs:
            self._codefile.write((" %s" % output['name']))
        self._codefile.write("\n")
                                               

        
    def _write_signal_definitions(self):
        """
        Writes assign statements for all logic operations in the
        order in which they appear in the internal list.
        """
        for gate in self._logic_operations:
            if gate['function'] == 'NOT':
                self._codefile.write(".names %s %s\n0 1\n" % (gate['input'], gate['output']))
            elif gate['function'] == 'AND':
                self._codefile.write(".names")
                for input_name in gate['inputs']:
                    self._codefile.write((" %s" % input_name))
                self._codefile.write((" %s\n" % gate['output']))
                for count in range(0, len(gate['inputs'])):
                    self._codefile.write('1')
                self._codefile.write(" 1\n")
            elif gate['function'] == 'OR':
                self._codefile.write(".names")
                for input_name in gate['inputs']:
                    self._codefile.write((" %s" % input_name))
                self._codefile.write(" %s\n" % gate['output'])
                for count in range(0, len(gate['inputs'])):
                    for inner_count in range(0, len(gate['inputs'])):
                        if inner_count == count:
                            self._codefile.write('1')
                        else:
                            self._codefile.write('-')
                    self._codefile.write(" 1\n")
                pass # end outer loop for OR minterms
            elif gate['function'] == 'MUX':
                self._codefile.write(".names %s %s %s %s\n" %(gate['sel'],
                                      gate['in_then'], gate['in_else'], gate['output']))
                self._codefile.write("0-1 1\n11- 1\n")
            else:
                raise MardukException(("ERROR! Unknown gate type '%s'!" % gate['function']))

        for output in self._outputs:
            self._codefile.write(".names %s %s\n" % (output['signal'], output['name']))
            self._codefile.write("1 1\n")

        self._codefile.write(".names one\n1\n")
        self._codefile.write(".names one zero\n0 1\n")
        
    
    def _write_latches(self):
        """
        Writes the initial block which initializes all regs (flipflops).
        """
        for ff in self._flipflops:
            self._codefile.write((".latch %s %s %s\n" % (ff['input'], ff['name'], ff['initial'])))
   
        
    def _write_end_module(self):
        """
        Writes the 'endmodule' line.
        """
        self._codefile.write(".end\n")


#############################################################################################
class BlifGenerator(CodeGenerator):
    """
    This class generates a BLIF file by directly dumping the BDDs of the output functions.
    TODO: Add more precise comment.
    """
    
    def __init__(self, marduk, output_functions):
        CodeGenerator.__init__(self, marduk.output_file, comment_sign='#')
        self._marduk = marduk
        self._output_functions = output_functions

        if marduk.transfer_functions:
            from nusmv import dd
            self.__dd_mgr = dd.create_dd_manager(0,0,251,131071,0)  # Values from PerlDD
            if marduk.dyn_reorder:
                dd.dd_autodyn_enable(self.__dd_mgr, marduk.dyn_reorder_method)


    def write_code_to_file(self):
        """
        Actually writes the BLIF file.
        """
        import re
        from nusmv import dd
        from bddwrap import BDD

        marduk_mgr = self._marduk.dd_mgr        
        inames = self._create_inames_list()
        (functions, onames) = self._create_functions_and_onames_list()

        mname = self._marduk.output_file
        mname = re.sub(r"^.*/", "", mname)  # remove path, keep filename only
        mname = re.sub(r"\..*", '', mname)  # remove extension

        if mname == None or mname == "":
            print "WARNING: Could not create a module name from the output-filename. Using 'main' as default."
            mname = "main"

        # BLIF header: .module, .inputs, .outputs, .latch
        self._write_blif_header(mname)
        
        # BLIF body: .names
        if self._marduk.transfer_functions:
            import resource
            
            before = resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime
            dd.dd_reorder(self.__dd_mgr, self._marduk.reorder_method, 0)
            self._reorder_time =  resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime - before
            mgr = self.__dd_mgr
        else:
            mgr = marduk_mgr
            
        dd.bdd_DumpBlifBody(mgr, functions, inames, onames, self._codefile)

        # BLIF footer: .end
        self._codefile.write("\n.end\n")

        for ptr in functions:
            dd.bdd_free(marduk_mgr, ptr)
        functions = None



    def _create_inames_list(self):
        from marduk_utils import comp_name_bdd_tuples
        from nusmv import dd
        from bddwrap import BDD
        list = []
        marduk_mgr = self._marduk.dd_mgr
        for var in self._marduk.vars:
            list.append((var.name + '_ps', var.ps.ptr, var.ps.mgr))
            list.append((var.name + '_ns', var.ns.ptr, var.ns.mgr))

        list.sort(cmp=comp_name_bdd_tuples)
                
        names = []
        for element in list:
            names.append(element[0])
            dd.bdd_free(marduk_mgr, element[1])
        list = None
        
        # The list of input names must begin with a dummy entry to match the "mysterious" variable
        # which is always introduced by NuSMV, and which always has the lowest index in the BDD.
        # Without this entry the mapping between BDD nodes and string names would be off-by-one,
        # and _ps and _ns entries would become confused.
        names = ["dummy"] + names
        
        return names

    def _create_functions_and_onames_list(self):
        functions = []
        onames = []
        import resource
        before = resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime
        for key in self._output_functions.functions.keys():
            if not self._marduk.transfer_functions:
                functions.append(self._output_functions.functions[key].ptr)
            else:
                from bddwrap import BDD
                transferred_bdd = BDD(self._output_functions.functions[key].ptr, self._marduk.dd_mgr, dest_mgr=self.__dd_mgr)
                transferred_ptr = transferred_bdd.ptr
                functions.append(transferred_ptr)
            onames.append(key)
            # print "Output name: %s" % key  # DEBUG
        self._transfer_time = resource.getrusage(resource.RUSAGE_SELF).ru_utime + resource.getrusage(resource.RUSAGE_SELF).ru_stime - before

        return (functions, onames)
                         

    def _write_blif_header(self, mname):
        import marduk_utils
        self._codefile.write(".model %s\n" % mname)

        self._codefile.write(".inputs")
        for var in self._marduk.input_vars:
            self._codefile.write(" %s" % var.name)
        self._codefile.write("\n")

        self._codefile.write(".outputs")
        for var in self._marduk.output_vars:
            self._codefile.write(" %s" % var.name)
        for var in self._marduk.state_vars:
            self._codefile.write(" %s" % var.name)
        self._codefile.write("\n")

        for var in self._marduk.input_vars:
            # Map (internal) inputs_ns names to external inputs
            self._codefile.write(".names %s %s\n" % (var.name, ("%s_ns" % var.name)))
            self._codefile.write("1 1\n")

        for var in self._marduk.output_vars + self._marduk.state_vars:
            # Map (internal) outputs_ns names to external outputs
            self._codefile.write(".names %s %s\n" % (var.name, ("%s_ns" % var.name)))
            self._codefile.write("1 1\n")

        init_bdd = self._marduk.winning_region.init12 * self._marduk.winning_region.initjx
        for var in self._marduk.vars:
            input = var.name + "_ns"
            output = var.name + "_ps"
            init = marduk_utils.get_init_value_from_bdd(var, init_bdd)
            self._codefile.write(".latch %s %s %d\n" % (input, output, init))

        
 
#############################################################################################    
class HifGenerator(CodeGenerator): 
    """
    Generates HIF code.
    """
    
    def __init__(self, output_file, module_name="main"):
        CodeGenerator.__init__(self, output_file, module_name=module_name, comment_sign='#')


    def write_code_to_file(self):
        """
        Generates HIF code according to the current values
        of the internal data structures (such as list of inputs/outputs/flipflops,
        logic operations,...) and writes it to the output file.
        This methode should only be called ONCE, and only after ALL circuit elements have been
        created and connected.
        """
        self._write_modul_head()
        self._write_open_contents()
        self._write_signal_declarations()
        self._write_reg_declarations()
        self._write_statetable_process() #always block
        self._write_globalaction()       #signal definitions
        self._write_close_contents()     #close bracket
        self._write_end_module()         #close brackets
        
       

    def _write_modul_head(self):
        """
        Writes the head and module  declaration in the following form:
        (SYSTEM name
            (DESIGNUNIT main
                (VIEW behav 
                (VIEWTYPE "")
                (DESIGN HARDWARE)
                (INTERFACE
                    (PORT clock (IN )(BIT ))
                    (PORT <input> (IN )(BIT ))
                        ...
                    (PORT <output> (OUT )(BIT ))
                        ...
                )

        """
        
        #First the header including the module name
        self._codefile.write("(SYSTEM name\n")
        self._codefile.write("  (DESIGNUNIT %s \n" % self._module_name)
        self._codefile.write("    (VIEW behav\n")
        self._codefile.write("    (VIEWTYPE \"\")\n")
        self._codefile.write("      (DESIGN HARDWARE)\n")       

        #Now the I/O list
        self._codefile.write("      (INTERFACE\n")
        self._codefile.write("        (PORT clock (IN) (BIT ))\n")
      
      
        for input_name in self._inputs:
            self._codefile.write(("        (PORT %s (IN) (BIT))\n" % input_name))

        for output in self._outputs[0:(len(self._outputs))]:
            self._codefile.write(("        (PORT %s (OUT) (BIT))\n" % output['name']))

        self._codefile.write("      )\n")


    def _write_open_contents(self):
        """
         Writes (CONTENTS
        """
        self._codefile.write("      (CONTENTS\n")
        
    def _write_close_contents(self):
        """
         Closes the content block with )
        """
        self._codefile.write("      )\n")
    
    
    def _write_signal_declarations(self):
        """
        Writes declarations for all signals, in the following order:
        Inputs, Outputs, internal wires, regs (flipflops).
        """

        #BE AWARE THAT'S BASED ON INITIALS ZERO AND ONE IN "REF_ZERO"
        for wire in self._tmp_vars:
            self._codefile.write(("        (SIGNAL %s (BIT ))\n" % wire))
            
            #The code is correct but the HIF suite would interpret one and zero as registers
            #if wire == "zero":
            #    self._codefile.write((" (INITIALVALUE '0'))\n"))
            #elif wire == "one":
            #    self._codefile.write((" (INITIALVALUE '1'))\n"))
            #else:
            #    self._codefile.write((")\n"))                

    def _write_reg_declarations(self):

        for ff in self._flipflops:
            self._codefile.write("        (VARIABLE %s (BIT )(INITIALVALUE  '%s') )\n" % (ff['name'], ff['initial']))
     
    def _write_statetable_process(self):
        """
        ALWAYS BLOCK: 
            (STATETABLE process 
              (SENSITIVITY (NAME  clock 
              (PROPERTY PROPERTY_SENSITIVE  "PROPERTY_SENSITIVE_POS")))
              (STATE process 
                (ASSIGN  x_p  x_n )
               )
             )
        """
        self._codefile.write("        (STATETABLE process\n")
        self._codefile.write("          (SENSITIVITY (NAME  clock\n")
        self._codefile.write("            (PROPERTY PROPERTY_SENSITIVE  \"PROPERTY_SENSITIVE_POS\")))\n")
        self._codefile.write("            (STATE process\n")
        
        for ff in self._flipflops:
            self._codefile.write("              (ASSIGN %s %s )\n" % (ff['name'], ff['input']))
          
        self._codefile.write("          )\n")
        self._codefile.write("        )\n")
        
    
    def _write_globalaction(self):
        """
        Writes assign statements for all logic operations in the
        order in which they appear in the internal list. 
        """
        
        self._codefile.write(("        (GLOBALACTION\n"))
                
    
        for gate in self._logic_operations:
            
            if gate['function'] == 'NOT':
                self._codefile.write(("          (ASSIGN  %s (!  %s ))\n" % (gate['output'], gate['input'])))
    
    
            elif gate['function'] == 'AND':
                #Build the assign statement in Prefix mode with help of a tmp str
                tmp_str = "          (ASSIGN " + gate['output']
                
                #First the operators
                for input_name in gate['inputs'][0:len(gate['inputs'])-1]:
                    tmp_str += " (&&"
                
                #the inner input
                tmp_str += " " + gate['inputs'][0]
                
                #the rest of the inputs with closing bracket
                for input_name in gate['inputs'][1:len(gate['inputs'])]:
                    tmp_str += " " + input_name + " )"
                
                tmp_str += ")\n"
                
                self._codefile.write(tmp_str)
    
    
            elif gate['function'] == 'OR':
                tmp_str = "          (ASSIGN " + gate['output']
                #First the operators
                for inputs in gate['inputs'][0:len(gate['inputs'])-1]:
                    tmp_str += " (||"
                
                #the inner input
                tmp_str += " " + gate['inputs'][0]
                
                #the rest of the inputs with closing bracket
                for input_name in gate['inputs'][1:len(gate['inputs'])]:
                    tmp_str += " " + input_name + " )"
                    
                tmp_str += ")\n"
                
                self._codefile.write(tmp_str)
    
    
            elif gate['function'] == 'MUX':
                self._codefile.write(("            (ASSIGN  %s (WHEN (ALT  %s  %s )(DEFAULT  %s )))\n" 
                                                    %(gate['output'], gate['sel'],  gate['in_then'], gate['in_else'])))
    
            else:
                raise MardukException(("ERROR! Unknown gate type '%s'!" % gate['function']))
                
                
        for output in self._outputs:
            self._codefile.write(("          (ASSIGN  %s  %s )\n" % (output['name'], output['signal'])))
            
        self._codefile.write("          (ASSIGN zero 0)\n")
        self._codefile.write("          (ASSIGN one  1)\n")
            
        self._codefile.write(("        )\n"))
    
        
    def _write_end_module(self):
        """
        Closes the brackets
        """
        self._codefile.write("    )\n  )\n\n")
                        
                        
    def append_comment(self, lines):
        """
        This method appends the given lines as a comment to the already existing code_file.
        If the file is still open, write directly to it, otherwise reopen and append.
        """
        was_open = False
        if ~self._codefile.closed:
            file = self._codefile
            was_open = True
        else:
            file = open(self._code_file_name, 'a')

        file.write('\n\n')
        file.write('  (PROPERTY comment \" ---------------------------------------------------------------------------\")\n')
        for line in lines:
            subs_line = line.replace('\n','\")\n' + '(PROPERTY comment \"' + ' ')
            file.write('(PROPERTY comment \"' + ' ' + subs_line + '\")\n')
        file.write(')\n')
        if ~was_open:
            file.close()
        
