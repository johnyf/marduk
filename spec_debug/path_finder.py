##  ===========================================================================
##  Author: Robert Koenighofer <robert.koenighofer@student.tugraz.at>
##
##  Copyright (c) 2009, 2010 by Graz University of Technology 
##
##  This is free software; you can redistribute it and/or
##  modify it under the terms of the GNU Lesser General Public
##  License as published by the Free Software Foundation; either
##  version 2 of the License, or (at your option) any later version.
##
##  This software is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
##  Lesser General Public License for more details.
##
##  You should have received a copy of the GNU Lesser General Public
##  License along with this library; if not, write to the Free Software
##  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.
##
##  For more information about this software see <http://rat.fbk.eu/ratsy>
##  or email to the RATSY Team <ratsy@list.fbk.eu>.
##  Please report bugs to <ratsy@list.fbk.eu>.
##
##  ===========================================================================

"""
Contains a class to compute a summarizing graph.
"""

from graph_node import GraphNode
from bddwrap import BDD
from countertrace_finder import CountertraceFinder
from spec_debug_utils import PLog

class PathFinder(object):
    """
    Able to compute a graph that summarizes all possible plays.

    This class is able to calculate all states and all state transitions
    which are feasible in the interactive game implemented in
    L{InteractiveGame}. All states and state transitions are visualized as a
    graph. The PathFinder is able to create a description of the
    graph in DOT format. The DOT-program can then be used to generate
    pictures of the graph by typing:
     - dot -Tpdf filename.dot -o filename.pdf

    3 Files are generated by the PathFinder's method write_graphs():

     - '<filename_prefix>.dot': contains a description of a graph that
        summarizes all states and state transitions. For every state, it
        contains information about the fairness condition the environment
        tries to fulfill next (the content of ix) and the fairness
        condition of the system which will be evaded (the content of jx).
        It further contains the maximal number of changes of jx as well as
        information about the fairness constraints of the system and the
        environment which are fulfilled in the states.
     - '<filename_prefix>_with_signals.dot': also contains the next
        inputs and the relevant next outputs for state transitions.
     - '<filename_prefix>.info': contains the values of all inputs and
        outputs in the different states.

    @author: Robert Koenighofer <robert.koenighofer@student.tugraz.at>
    @version: 1.0.0
    """

    def __init__(self, utils, counterstrategy, z_array, countertrace,
                 abort = None):
        """
        Constructor

        @param utils: A module containing a lot of utility-functions as
               well as data which is needed almost everywhere.
        @type utils: L{SpecDebugUtils}
        @param counterstrategy: A counterstrategy, i.e., a strategy for the
               environment to find inputs so that the system is forced to
               violate the specification.
        @type counterstrategy: L{BDD}
        @param z_array: z_array[a] contains the intermediate results of the
               fixpoint computation in the variable Z of the computation of
               the winning region for the environment. 'a' counts the
               iterations of the fixpoint computation in Z. It is used to
               figure out how often the value of jx might still change in the
               future of the play. (If the play is in z_array[a], jx might
               change at most a-1 times.)
        @type z_array: list<L{BDD}>
        @param countertrace: A sequence of inputs so that the system is forced
               to violate its specification.
        @type countertrace: L{InfiniteTraceOfBdds}
        @param abort: The number of states after which the computation should
               be aborted or None, if it should not be aborted at all.
        @type abort: int
        """

        #: A module containing a lot of utility-functions.
        #: @type: L{SpecDebugUtils}
        self.__utils = utils

        #: A winning strategy for the environment.
        #: @type: L{BDD}
        self.__counterstrategy = counterstrategy

        #: Intermediate results of the fixpoint computation in the variable Z.
        #: @type: list<L{BDD}>
        self.__z_array = z_array

        #: A sequence of inputs so that the system is forced to violate its
        #: specification.
        #: @type: L{InfiniteTraceOfBdds}
        self.__countertrace = countertrace

        #: The number of states after which the computation should be aborted
        #: or None, if it should not be aborted at all.
        #: @type: int
        self.__abort = abort

        #: All nodes of the graph. 
        #: @type: list<L{GraphNode}>
        self.__graph_nodes = []

    def get_graph(self):
        """
        Returns the nodes of the graph.

        This method returns the nodes of the graph (after compute_graph has
        been called).

        @return: The nodes of the graph.
        @rtype: list<L{GraphNode}>
        """
        return self.__graph_nodes

    def write_graphs(self, filename_prefix, destroy = True):
        """
        Computes a graph that summarizes all possible plays.

        This method is able to calculate all states and all state transitions
        which are feasible in the interactive game implemented in
        L{InteractiveGame}. All states and state transitions are visualized
        as a graph. The PathFinder is able to create a description of the
        graph in DOT format. The DOT-program can then be used to generate
        pictures of the graph by typing:
         - dot -Tpdf filename.dot -o filename.pdf

        3 Files are generated:

         - '<filename_prefix>.dot': contains a description of a graph
            that summarizes all states and state transitions. For every state,
            it contains information about the fairness condition the
            environment tries to fulfill next (the content of ix) and the
            fairness condition of the system which will be evaded (the content
            of jx). It further contains the maximal number of changes of jx as
            well as information about the fairness constraints of the system
            and the environment which are fulfilled in the states.
         - '<filename_prefix>_with_signals.dot': also contains the next
            inputs and the relevant next outputs for state transitions.
         - '<filename_prefix>.info': contains the values of all inputs
            and outputs in the different states.

        @param filename_prefix: The prefix in the name of the files to
               generate.
        @type filename_prefix: string
        @param destroy: True if the graph should be destroyed after it has been
               written, and False otherwise.
        @type destroy: bool
        @return: True if the computation finished successfully, False if it was
                 aborted as the number of nodes exceeds self.__abort. In case
                 of False, no files are written.
        @rtype: bool
        """

        # cleaning up the result of all previous computations:
        self.__graph_nodes = []

        # computing the graph as as list of GraphNodes in self.__graph_nodes:
        success = self.compute_graph()
        if not success:
            return False

        # uncomment the following lines to check if a graph is system
        # independent:
        # tracer_finder = CountertraceFinder(self.__utils)
        # tracer_finder.is_graph_system_independent(self.__graph_nodes)

        # writing the file with the detailed information about the states
        # of the graph:
        info_file = open(filename_prefix + ".info", 'w')
        for node in self.__graph_nodes:
            info_file.write(node.print_node_info())
        info_file.close()

        # print the graph without signals (without inputs and outputs)
        self.print_graph(filename_prefix + ".dot", False)

        # print the graph with signals (with inputs and outputs)
        self.print_graph(filename_prefix + "_with_signals.dot", True)

        # Remove all circular references:
        # This is necessary as the garbage collector of Python cannot destroy
        # nodes when they have circular references.
        if destroy:
            for node in self.__graph_nodes:
                node.unlink()
        return True


    def compute_graph(self):
        """
        Computes the graph.

        This method is able to compute the graph with a simple depth first
        search algorithm that starts in the initial state. The initial state
        is added to the list of examined states self.__graph_nodes. Then all
        successor states are recursivly computed and added to the list of
        examined states as well. Whenever a state has already been examined
        (is already in self.__graph_nodes), its successor states are not
        examined any more (as they have already been examined). Thus the
        recursion stops eventually.

        @return: True if the computation finished successfully, False if it was
                 aborted as the number of nodes exceeds self.__abort.
        @rtype: bool
        """

        # we start in the initial state:
        current_state = self.__utils.init_ix_jx

        # The method _add_nodes_recursivly works recursively, so it also adds
        # the successors (and their successors) to the graph as well:
        step_count = 0
        return self._add_nodes_recursivly(current_state, None, step_count)


    def print_graph(self, filename, include_signals):
        """
        Prints the graph.

        This method is able to print a description of the computed graph in
        DOT-format. The DOT-program can then be used to generate pictures of
        the graph by typing:
         - dot -Tpdf <filename> -o filename.pdf
        With include_signals=True, inputs and outputs are included in the
        graph, otherwise they are not.

        @param filename: The name of the file to write.
        @type filename: string

        @param include_signals: True if inputs and outputs should be included
               in the graph, False otherwise
        @type include_signals: bool
        """

        # Open a file for the graph in dot format:
        dot_file = open(filename , 'w')

        # Print some header into the dot-file that contains some
        # explanations:
        self._print_dot_file_header(include_signals, dot_file)

        # Compute the next inputs which are constant for all states and which
        # change from state to state:
        if include_signals:
            self._add_inputs_to_graph(dot_file)

        # Write the file:
        for node in self.__graph_nodes:
            dot_file.write(node.print_node_dot(include_signals))
            dot_file.write(node.print_edges_to_succ_dot(include_signals))
        dot_file.write("}\n")

        # Close the file again:
        dot_file.close()


    def _add_nodes_recursivly(self, current_state, parent_node, step_count):
        """
        Recursively adds a state as a node to the graph.

        This method adds a state as a node to the graph. It works recursively
        with a simple depth first search algorithm, so all successors of the
        state (as well as their successors) are added as nodes to the graph
        as well.

        @param current_state: The new state to add.
        @type current_state: L{BDD}
        @param parent_node: The node which is the predecessor of this state.
        @type parent_node: L{GraphNode}
        @param step_count: The current time step counter.
        @type step_count: int
        @return: True if the computation finished successfully, False if it was
                 aborted as the number of nodes exceeds self.__abort.
        @rtype: bool
        """


        # Abort if the number of nodes exceeds self.__abort
        if self.__abort and len(self.__graph_nodes) > self.__abort:
            return False

        # A concrete next input is chosen either according to the
        # counterstrategy or according to the countertrace:
        next_input = self.__utils.get_next_inputs(current_state, \
                                                  step_count, \
                                                  self.__counterstrategy, \
                                                  self.__countertrace)

        # Choose the next jx variables (rho2 may allow more than one):
        for jx_var in self.__utils.jx_variables:
            (v, next_input) = self.__utils.choose_val(next_input, jx_var, True)

        # We also need to find out the next input value, since we store this
        # value in the graph node. This is necessary for the following
        # reason: If a graph is computed from a countertrace (and not just
        # from a counterstrategy) the next input might be different from the
        # same state depending on the step count. We have to draw different
        # graph nodes for equal states with different next inputs.
        input_only = self.__utils.keep_only_next_inputs(next_input)

        # Adding the state as a node to the graph:
        # _add_state returns continue_recursion=0 if the state was already
        # added. We can abort the recursion in this case, since all
        # successors have already been added as well:
        (current_node, continue_recursion) = \
                    self._add_state(current_state, parent_node, input_only)
        if not continue_recursion:
            return True

        # computing all possible next outputs:
        possible_next_outputs = next_input * self.__utils.sys_trans

        # compute all possibilities of output vars, where we have a choice:
        next_states = self._compute_possible_next_states(possible_next_outputs)

        # add all successor states recursively to the graph:
        for next in next_states:
            succ = self._add_nodes_recursivly(next, current_node, step_count+1)
            if not succ:
                return False
        return True

    def _add_state(self, state_bdd, parent_node, next_input):
        """
        Adds a node to the graph.

        This method adds a state as a node to the graph if a node for this
        state does not already exist.

        @param state_bdd: The new state to add.
        @type state_bdd: L{BDD}
        @param parent_node: The node which is the predecessor of this state.
        @type parent_node: L{GraphNode}
        @param next_input: The next input in the state
        @type next_input: L{BDD}
        @return: (state_node, continue_recursion) where:
                  - state_node is the (created or found) node corresponding to
                    state_bdd
                  - continue_recursion is False if the state (and its possible
                    successors) has already been processed, and True if not
        @rtype: (L{GraphNode}, bool)
        """

        if not parent_node:
            # This is the initial state, all other states have a parent
            state_node = self._create_graph_node(state_bdd, next_input)
            self.__graph_nodes.append(state_node)
            return (state_node, True)

        # Check if the state was already added to the graph
        for state_node in self.__graph_nodes:
            if state_bdd == state_node.bdd and \
               next_input == state_node.next_input:
                # If the state was already added to the graph, we just have to
                # add it as successor of the parent:
                state_node.add_predecessor(parent_node)
                parent_node.add_successor(state_node)
                return (state_node, False)

        # If we are here, the state was not already added to the graph. We
        # have to create a new graph node:
        state_node = self._create_graph_node(state_bdd, next_input)
        state_node.add_predecessor(parent_node)
        parent_node.add_successor(state_node)
        self.__graph_nodes.append(state_node)
        return (state_node, True)



    def _create_graph_node(self, state_bdd, next_input):
        """
        Creates a new graph node.

        This method creates a new L{GraphNode} corresponding to a
        certain state in the play between the system and the environment.

        @param state_bdd: The state in the play to generate a graph node for.
        @type state_bdd: L{BDD}
        @param next_input: The next input in this state.
        @type next_input: L{BDD}
        @return: A graph node for the state in the game.
        @rtype: L{GraphNode}
        """

        state_node = GraphNode(self.__utils)
        state_node.bdd = state_bdd
        state_node.next_input = next_input
        index_of_new = len(self.__graph_nodes)
        state_node.name = "S%d" % index_of_new
        state_node.jx_val = self.__utils.get_decimal_jx_val(state_bdd, False)
        state_node.ix_val = self.__utils.get_decimal_ix_val(state_bdd, False)
        (env_fulfilled,sys_fulfilled) = self._get_fulfilled_fariness(state_bdd)
        state_node.fulfilled_env = env_fulfilled
        state_node.fulfilled_sys = sys_fulfilled
        nr_changes = self.__utils.how_often_may_jx_change(state_bdd, \
                                                          self.__z_array)
        state_node.changes_of_jx = nr_changes
        return state_node
        

    def _compute_possible_next_states(self, possible_next_states):
        """
        Computes all possible successor states.

        Given a bdd that contains all possible next states, this method
        returns a list of bdds, each representing one successor state.

        @param possible_next_states: A bdd where all present variables
               are fixed as well as all next input variables. The only
               choices are in the next output variables.
        @type possible_next_states: L{BDD}
        @return: A list of bdds representing all possible next states.
        @rtype: list<L{BDD}>
        """

        minterms = self._compute_output_minterms(possible_next_states)
        next_states = []
        for minterm in minterms:
            state = self.__utils.swap_present_next(minterm)
            state = self.__utils.keep_only_present(state)
            if (state * self.__utils.sys_trans).isNotZero():
                next_states.append(state)
        return next_states
        

    def _compute_output_minterms(self, bdd):
        """
        Computes the minterms of a bdd with respect to relevant next outputs.

        This method computes and returns the minterms of a bdd with
        respect to the next output variables. It works recursively: All
        relevant outputs are examined. If a variable can be True and False
        the algorithm is called recursivly with the bdd where the variable
        is True and False respecitvely. The results are then merged.

        @param bdd: The bdd for which the minterms should be computed.
        @type bdd: L{BDD}
        @return: All minterms of the bdd with respect to relevant next
                 outputs.
        @rtype: list<L{BDD}>
        """

        if bdd.isZero():
            # One of the trivial cases where the recursion stops:
            return []

        for var in self.__utils.relevant_out_vars:
            (can_be_1, can_be_0) = self.__utils.get_val(bdd, var, True)
            if can_be_1 and can_be_0:
                # recursive call where the variable is False:
                list_f = self._compute_output_minterms(bdd * (~var.ns))

                # recursive call where the variable is True:
                list_t = self._compute_output_minterms(bdd * var.ns)
                list_f.extend(list_t)
                return list_f

        # The other trivial case where the recursion stops:
        return [bdd]



    def _get_fulfilled_fariness(self, state):
        """
        Returns the indices of the fulfilled fairness conditions.

        This method finds out which fairness conditions (of the system and
        the environment) are fulfilled in a certain state and returns the
        indices of the fairness conditions as string.

        @param state: The state to examine.
        @type state: L{BDD}
        @return: A tuple (env_fulfilled, sys_fulfilled) where
                  - env_fulfilled is a string containing the indices of the
                    environment fairness conditions that are fulfilled in
                    'state'.
                  - sys_fulfilled is a string containing the indices of the
                    system fairness conditions that are fulfilled in 'state'.
        @rtype: (string, string)
        """

        env_fulfilled = ""
        sys_fulfilled = ""

        # check fairness conditions of the environment:
        for i in range(0, len(self.__utils.assumptions)):
            if (self.__utils.assumptions[i] * state).isNotZero():
                env_fulfilled += "%d," %i
            
        # get rid of the last ',':
        env_fulfilled = env_fulfilled[0:-1]

        # check fairness conditions of the system:
        for i in range(0, len(self.__utils.guarantees)):
            if (self.__utils.guarantees[i] * state).isNotZero():
                sys_fulfilled += "%d," %i

        # get rid of the last ',':
        sys_fulfilled = sys_fulfilled[0:-1]

        return (env_fulfilled, sys_fulfilled)


    def _print_dot_file_header(self, include_signals, dot_file):
        """
        Prints a header into the DOT-file.

        This header contains some explanations to the nodes in the graph.

        @param include_signals: True if inputs and outputs are included in the
               graph, False otherwise.
        @type include_signals: bool
        @param dot_file: The file to write to.
        @type dot_file: File
        """

        dot_file.write("digraph G {\n")
        dot_file.write("  rankdir=LR;\n")
        dot_file.write("  node [shape = record];\n")
        dot_file.write("  subgraph cluster1 {\n")
        dot_file.write("    A[label = \"NodeName (see graph.info)")
        dot_file.write("|{all i such that\\nenv_fairness[i]\\nis fulfilled|")
        dot_file.write("the ix such that\\nenv_fairness[ix]\\nis met next}")
        dot_file.write("|{all j such that\\nsys_fairness[j]\\nis fulfilled|")
        dot_file.write("the jx such that\\nsys_fairness[jx]\\nis evaded}")
        dot_file.write("| the k, such that jx changes at \\n ")
        dot_file.write("most k times in the future")
        if include_signals:
            dot_file.write("|changing next input values")
        
        dot_file.write("\"];\n")
        dot_file.write("    label = \"Explanation\";\n")
        dot_file.write("    color=blue;\n")
        dot_file.write("  }\n")
        dot_file.write("  A->S0[color=white];\n")



    def _add_inputs_to_graph(self, dot_file):
        """
        Adds input values to the graph.

        This method adds the information about the next values of the inputs
        into the graph. All inputs that do not change are written into a
        seperate box in the graph. All inputs that do change are written into
        the nodes in the graph.

        @param dot_file: The file to write to.
        @type dot_file: File
        """

        # Find out, which next input values are changing, and which are
        # constant:
        next_in = BDD.ZERO(self.__utils.dd_mgr)
        for node in self.__graph_nodes:
            next_in += node.next_input

        changing_next_in_vars = []
        constant_next_in_vars = []
        for in_var in self.__utils.input_vars:
            (can_be_1, can_be_0) = self.__utils.get_val(next_in, in_var, True)
            if can_be_1 and can_be_0:
                changing_next_in_vars.append(in_var)
            else :
                constant_next_in_vars.append(in_var)

        # print the values of the constant next inputs:
        dot_file.write("ConstantNextInputs[label=")
        dot_file.write("\"Constant next input values:\\n ")
        for const in constant_next_in_vars:
            symb = self.__utils.get_val_as_string(next_in, const, True)
            dot_file.write(const.name + "=" + symb + "\\n ")
        
        dot_file.write("\"];\n")

        # add the values for the changing next inputs into the graph nodes:
        for node in self.__graph_nodes:
            next_input = node.next_input
            for changing_next_in in changing_next_in_vars:
                (can_be_1, can_be_0) = \
                        self.__utils.get_val(next_input, changing_next_in, True)
                node.add_next_input_to_print(changing_next_in.name, can_be_1)
